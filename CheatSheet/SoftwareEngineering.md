**Программная инженéрия** определяется как системный подход к анализу, проектированию, оценке, реализации, тестированию, обслуживанию и модернизации программного
обеспечения. Программная инженерия занимается разработкой систематических моделей и надежных методов производства высококачественного программного обеспечения, и данный подход распространяется на все уровни - от теории и принципов до реальной практики создания программного обеспечения.

**Технология программирования** - изучение процессов программной инженерии, методов и инструментальных средств.


## Подходы к разработке программных средств. Их краткая характеристика.

Методы разработки программного обеспечения.

#### Метод функциональной декомпозиции.

Область применения: алгоритмически сложные задачи, не связанных с обработкой большого объема информации. (многие инж. задачи)

Задача делится на 2-8 подзадач (оптимально 3-5), каждая подзадача должна быть логически целой с чётко фиксированным набором исходных данных и результатом, любая задача более высокого уровня должна быть сведена к решению выделенных подзадач. Подзадачи также делятся на подзадачи, и т.д., пока не будут достигнуты критерии останова. Существует 2 критерия останова:
А) Выделена ПЗ, которая уже решена, или методы решения которой хорошо известны.
Б) Подзадача соответствует программно-разумным размерам. (ПРР – логику программы легко держать  в голове, т.е. не более 3-х экранов)

Иерархическая диаграмма:
![Метод Функциональной Декомпозиции](МетодФункциональнойДекомпозиции.png)

IPO - диаграмма (Input - Processing - Output: Ввод- Обработка - Вывод) должна соответствовать каждому узлу предыдущей диаграммы
![ВводОбработкаВывод](ВводОбработкаВывод.png)


####  Анализ потоков данных
Немного устарел, но может быть использован, например, при автоматизации малых офисов.

Диаграмма потоков данных (DFD, Data Flow Diagram):

![Диаграмма Потока Данных](ДиаграммаПотокаДанных.png)

#### Объектно-ориентированный подход

**Объект** - это реально существующий предмет со всеми его индивидуальными особенностями.

**Класс** - это множество объектов с одинаковыми свойствами и одинаковым поведением

#### Agile-методики
**Принципы:**
1. Нашим наивысшим приоритетом является удовлетворение клиента посредством ранней и непрерывной поставки ценного программного обеспечения.
2. Приветствуем изменение требований, даже на поздних стадиях разработки.
3. Agile-процессы позволяют использовать изменения для обеспечения заказчику конкурентного преимущества.
4. Работающий продукт следует выпускать как можно чаще, с периодичностью от пары дней до пары месяцев.
5. На протяжении всего проекта разработчики и представители бизнеса должны ежедневно работать вместе.
6. Над проектом должны работать мотивированные профессионалы. Чтобы работа была сделана, создайте условия, обеспечьте поддержку и полностью доверьтесь им.
7. Непосредственное общение является наиболее практичными эффективным способом обмена информацией как с самой командой, так и внутри команды.
8. Работающий продукт - основной показатель прогресса.
9. Инвесторы, разработчики и пользователи должны иметь возможность поддержать постоянный ритм бесконечно. Agile помогает наладить такой устойчивый процесс разработки.
10. Постоянное внимание к техническому совершенству и качеству проектирования повышает гибкость проекта.
11. Простота - искусство минимизации лишней работы - крайне необходима.
12. Самые лучшие требования, архитектурные и технические решения рождаются у самоорганизующихся команд.
13. Команда должна систематически анализировать возможные способы улучшения эффективности и соответственно корректировать стиль своей работы.

**SCRAM-технология и экстремальное (ХР) программирование**
- Постоянное сотрудничество заказчика и разработчика, от постановки задачи до тестирования.
- Разработка маленькими шагами, результаты которых тут же тестируются и будут предъявлены заказчику.
- Пожелания заказчика по усовершенствованию по возможности тут же будут реализованы.
- Разработку ведет относительно малочисленная группа специалистов, которые друг другу полностью доверяют, могут договориться. Отсутствует руководитель проекта, который распределяет задания и проверяет их выполнение.

**Критерии применения гибких методик**

Важны два параметра: критичность и масштаб.

_Критичность_ определяется последствиями потери работоспособности программного
обеспечения. Выделены 4 уровня:
- `С` - потеря удобства.
- `D` - потеря восстанавливаемых ресурсов (материальных, финансовых).
- `Е` - потеря невосстанавливаемых ресурсов (материальных, финансовых).
- `L` - угроза техногенных катастроф.

Масштаб определяется количеством занятых в разработке специалистов:
- 1 - 6: малый,
- 7 - 20: средний,
- Более 20: большой.
-
Гибкие методики могут применяться при критичности С и В и при малых и средних разработках.

## Жизненный цикл программного продукта. Основные понятия.

**Жизненный цикл** - это развитие системы, продукта, услуги, проекта или других изготовленных человеком объектов, начиная со стадии разработки концепции и заканчивая прекращением применения.
Другими словами можно сказать, что жизненный цикл программного обеспечения охватывает промежуток времени от возникновения необходимости в нем до завершения его эксплуатации.
При возникновении такой необходимости возникает и вечный вопрос: приобрести уже готовый продукт или разработать собственный.

#### Процессы жизненного цикла
1. Процесс анализа требований (функциональных и нефункциональных) к программным средствам
2. Процесс проектирования архитектуры программных средств - разработка общих принципов построения.
3. Процесс детального проектирования программных средств - из каких компонентов будет состоять, какие будут базы данных
4. Процесс конструирования программных средств - написание текстов программ и локальная отладка
5. Процесс комплексирования программных средств - сборка всех компоненов и проверка их работоспособности.
6. Процесс квалификационного тестирования программных средств - заключительное тестирование проводит не автор программы
  - _альфа_ - внутри компании разработчика, но без участия разработчиков
  - _бета_ - использование потенциальными пользоваетелями некоммерческой версии программы
7. Поставка и внедрение (использование программы без присутствия разработчика)
  - Опытная эксплуатация - работают разработчик и пользоваетль.
  - Промышленная эксплуатация - программа работает в реальных условиях без постоянного пристутствия разработчика.
8. Сопровожение программного продукта
  - устранение выявленных ошибок, внесение изменений, вызванных внешними факторами,
  - накопление предложений для разработки следующей версии,
  - внесение непринципиальных усовершенствований,
  - организованный переход к следующей версии с минимальными затратами

**Укрупненная модель жизненного цикла** (разработка небольших программных средств)
- анализ требований (превращение прикладной задачи в программистскую)
- проектирование структуры;
- программирование, тестирование, отладка;
- сборка, валидация, верификация (+ на этом этапе надо убедиться, что программа удовлетворяет требованиям, определенным на первом этапе)
- внедрение;
- сопровождение.

**Валидация** (validation): подтверждение того, что требования, предназначенные для конкретного использования или применения, выполнены. Валидация представляет собой совокупность действий, гарантирующих и обеспечивающих уверенность в том, что система способна реализовать свое предназначение, текущие и перспективные цели.

**Верификация** (verification): подтверждение того, что заданные требования полностью выполнены. Верификация представляет собой совокупность действий по сравнению полученного результата жизненного цикла с требуемыми характеристиками для этого результата.

## Модели жизненных циклов программного обеспечения, их характеристики и области применения.

В ходе реализации разработчик должен определить модель жизненного цикла, соответствующую области применения, размерам и сложности проекта. Модель жизненного цикла должна содержать стадии, цели и выходы каждой стадии. Виды деятельности и задачи процесса реализации программных средств должны быть выбраны и отражены в модели жизненного цикла. Эти виды деятельности и задачи могут пересекаться или взаимодействовать друг с другом, могут выполняться итеративно или рекурсивно.

Модель жизненного цикла показывает как между собой связаны этапы разработки программного обеспечения.

**Каскадная модель - водопад**

Особенности: полностью отсутствуют обратные связи (каждый этап считается полностью законченным до перехода к следующему), что упрощает процесс разработки, но является слишком жёстким требованием для реализации сложных проектов; ошибка, допущенная на этапе анализа, пересекает весь проект, и исправлять её сложно.

По этой модели можно работать в 2 случаях: разработка очередной версии существующего ПО; реализация простого проекта опытным разработчиком.

Устранение ошибок, допущенных на ранних этапах обойдется намного дороже исправления ошибок, допущенных на более поздних

Источник - статья У.Ройса 1970 года, из которой эта модель была выделена по ошибке.

![Каскадная Модель](КаскаднаяМодель.png)


## Особенности модели жизненного цикла «спираль»

Особенности: Раскручивается версия за версией, постепенно расширяется функционал. В идеале расширение аддитивное (внесение нового, без изменения старого).

Проблема: Успех разработки в большой степени определяется тем, в какой последовательности выбрана реализация. Основной принцип - как в строительстве: сначала фундамент (то есть общие части) и т.д. То есть при получении задачи нужно узнать, какие нужно накапливать данные, чтобы развивать данную задачу.

Применяется регрессионное тестирование, то есть в начале нужно провести тесты, предназначенные для предыдущей версии.

Предпроектное исследование - анализ рисков - принятие решения - разработка первой версии (м.б. прототипом) - анализ рисков (результатов)...

![Спираль](Спираль.png)

## Методы «быстрой разработки» их суть и условия применения.

Быстрая разработка приложений (RAD, rapid application development) - это жизненный цикл процесса проектирования, созданный для достижения более высокой скорости разработки и качества ПО и более низкой стоимости разработки, чем это возможно при традиционном подходе к проектированию.

Технологию RAD целесообразно применять, если:
-  Необходимо выполнение проекта в сжатые сроки.
-  Нечетко определены требования к ПО.
-  Проект выполняется в условиях ограниченности бюджета.
-  Интерфейс пользователя главный фактор.
-  Возможно разбиение проекта на функциональные компоненты.
-  Низкая вычислительная сложность ПО.

Основные принципы RAD:
- Работа ведется группами (руководитель, аналитик, два программиста, технический писатель) Если проект сложный, то для него может быть выделено несколько RAD-групп. Разработка проекта выполняется в условиях тесного взаимодействия между разработчиками и Заказчиком.
- Разработка базируется на моделях. Моделирование позволяет оценить проект и выполнить его декомпозицию на составные части, каждая из которых может разрабатываться отдельной RAD-группой.
- Итерационное прототипирование. Разработка системы и предъявление ее заказчику осуществляется в виде последовательности развиваемых прототипов. Любой из прототипов реализует определенную часть функциональности, требуемой от конечного продукта. При этом каждый последующий прототип включает всю функциональность, реализованную в предыдущем прототипе, с добавлением новой. Традиционно для проектов ПО средней сложности разрабатываются три прототипа. Первый содержит весь пользовательский интерфейс с нулевой функциональностью. Второй прототип содержит реализованную на 70-80% функциональность системы, третий – полностью реализованную функциональность.
- RAD группа всегда работает только над одним прототипом.
- Если проект сложный, то для него может быть выделено несколько RAD групп.
- Обязательное использование инструментальных средств, автоматизирующих процесс разработки, и методик их использования, следствием чего является сокращение сроков разработки и повышение качества конечного продукта.


## Планирование разработки программного обеспечения. LOC и FP-метрики. СОСОМО модель.

**План разработки программного обеспечения** (план проекта). План определяет _порядок работ, ресурсы, обязанности,_ и так далее. Может быть как маленьким и относительно неформальным так и большим и полностью официальным. Создание плана проекта столь же важно, как и само проектирование кода.

Процесс руководства программным проектом начинается с множества действий, объединяемых общим названием **планирование проекта**. Первое из этих действий - **_выполнение оценки_**. Очень важно провести оценку с минимальным риском.

Цель выполнения оценки проекта на основе LOC- и FP-метрик - сформировать предварительные оценки, которые позволят:
- предъявить заказчику корректные требования по стоимости и затратам на разработку программного продукта;
- составить план программного проекта.
При выполнении оценки возможны два варианта использования LOC- и FP-данных:
- в качестве оценочных переменных, определяющих размер каждого элемента продукта;
- в качестве метрик, собранных за прошлые проекты и входящих в метрический базис фирмы.


#### LOC и FP-метрики.

**Размерно-ориентированные метрики** прямо измеряют программный продукт и процесс его разработки. Основываются размерно-ориентированные метрики на LOC-оценках (Lines Of Code). LOC-оценка — это количество строк в программном продукте.

Достоинства размерно-ориентированных метрик (основываются на LOC - lines of code):
- широко распространены;
- просты и легко вычисляются.

Недостатки размерно-ориентированных метрик:
- зависимы от языка программирования;
- требуют исходных данных, которые трудно получить на начальной стадии проекта;
- не приспособлены к непроцедурным языкам программирования.

**Функционально-ориентированные метрики** косвенно измеряют программный продукт и процесс его разработки. Вместо подсчета LOC-оценки при этом рассматривается не размер, а функциональность или полезность продукта. Используется 5 информационных характеристик для подсчета FP (Function Points):
- Количество внешних вводов
- Количество внешних выводов
- Количество внешних запросов
- Количество внутренних логических файлов
- Количество внешних интерфейсных файлов

После сбора всей необходимой информации приступают к расчету метрики — количества
функциональных указателей.

Достоинства функционально-ориентированных метрик: не зависят от ЯП, легко вычисляются на любой стадии проекта.

Недостаток функционально-ориентированных метрик: результаты основаны на субъективных данных, используются не прямые, а косвенные измерения.

**COCOMO** - Constructive Cost Model (модель издержек разработки). Оценка стоимости программного продукта.


## Виды контроля программ; статические и динамические методы контроля. Тестирование  и отладка.

#### Виды контроля программ
- визуальный контроль - чтение программы (проверка условий в условных операторах и цаклах, возможность не завершения итерационных циклов и т.д.)
- Статический контроль – проверка программы по ее тексту без выполнения с помощью инструментальных средств. Синтаксический контроль выполняется компилятором.
- Динамический контроль – проверка правильности программы и ее выполнение на компьютере.

[Еще](https://life-prog.ru/view_ppdkss.php?id=18)

#### Тестирование  и отладка.
Тестирование — это запуск программы на разных наборах исходных данных — тестах и анализ полученных результатов с целью обнаружения ошибок.

Заключительное тестирование проводит не автор программы.

Виды тестирования:
- _альфа-тестирование_ - внутри компании разработчика, но без участия разработчиков
- _бета-тестирование_ - использование потенциальными пользоваетелями некоммерческой версии программы

Отладка - выявление причин некорректного поведения программы и их устранение.

## Методы функционального тестирования.

Функциональное тестирование является одним из ключевых видов тестирования, задача которого — установить соответствие разработанного программного обеспечения исходным функциональным требованиям заказчика. Проведение функционального тестирования — процесс, позволяющий проверить способность информационной системы работать в определенных условиях и решать задачи, нужные пользователям.

#### Метод эквивалентного разбиения.

Множество значений исходных данных разделяют на непересекающиеся подмножества таким образом, чтобы внутри каждого подмножества все значения были равносильны в качестве теста, но значения из разных подмножеств — нет.

Правильный класс эквивалентности — это допустимые значения исходных данных, неправильный класс эквивалентности — недопустимые значения. Например, для функции `у = ln(x)` допустимым классом эквивалентности является `x>0`, недопустимым `x<=0`.

#### Метод граничных значений.

Этот метод требует использовать в качестве тестов значения на границах и около границ классов эквивалентности.

Для уменьшения количества тестов рекомендуют использовать эти два метода совместно: сначала составить тесты по эквивалентному разбиению, а затем подкорректировать их таким образом, чтобы соблюдались рекомендации второго метода.

## Методы структурного тестирования. Граф управления программы. Тестирование путей, цикломатическая сложность программы.

В любой программе присутствуют три базовых конструкции: последовательность, выбор и повторение (цикл). Последовательности в графе управления можно ставить в соответствие одну вершину или столько вершин, сколько действий имеется в последовательности. Любой повтор (цикл) может быть реализован через выбор. Оператору цикла ставится в соответствие столько вершин графа, сколько условий продолжения (прерывания) цикла.

Для тестирования «белого ящика» необходимо пропускать столько тестов, сколько путей имеется на графе управления.

Интерпретация: цикломатическая сложность — это количество путей от первой вершины до последней.

Цикломатическая сложность программы определяется по формуле `Количество_ребер - количество_вершин + 2`. Цикломатическая сложность последовательности всегда равна единице. Поэтому можно при составлении графа управления программой последовательность представить одной вершиной.

Пример графа управления для следующего фрагмента:
```cpp
x = 3.4;
z = x * y;
if (z > 7.2) n++;
else m++;
y = z * n;
```
![Граф Управления](ГрафУправления.png)

## Совместное использование функционального и структурного тестирования.

Тестирование «серого ящика»:
1. На основе спецификации программы составим тесты методами «черного ящика». Допустим, получили N тестов.
2. Пусть на графе управления существует M путей.

Возможны следующие случаи:
1. `N = M` и составленные тесты обеспечивают прохождение всех путей по меньшей мере по одному разу. Все хорошо!
2. `N = M`, но обеспечивается прохождение лишь K путей (K < M). Если оставшиеся М-К путей противоречивые, то два или более теста будут пройдены по одному и тому же пути. Если это так и должно быть, то можно, в принципе, уменьшить количество тестов, но вполне возможно, что этого не стоит делать! Если так не должно быть (два теста пройдут по одному пути, но на самом деле они разные) — значит в программе ошибка!
3. `N = M`, но обеспечивается прохождение лишь K путей (K < M), среди оставшихся М-К путей имеются реальные, то не все протестировано и количество тестов надо увеличить.
4. `N < M`. Если оставшиеся М-N путей противоречивые, то все хорошо, можем приступить к тестированию, но если это не так, то придется составить и для них тесты.
5. `M < N`, значит, два или более теста пройдут по одному и тому же пути. Если так и должно быть, то некоторые случаи будут протестированы повторно. Если нет, то два разных случая пройдут по одному и тому же пути и в программе ошибка.

## Тестирование программных комплексов, построенных методом функциональной декомпозиции

[Тут про сам метод](#метод-функциональной-декомпозиции)

1. **_Монолитное_** тестирование. Все составные части тестируются независимо друг от друга, и после завершения этого выполняется сборка всего комплекса. Такую сборку иногда называют» «большой скачок».
2. **_Пошаговое_** (или **_инкрементное_**) тестирование, где протестированные модули тут же подключают к комплексу, тестирование и сборка выполняются параллельно. Пошаговое тестирование может выполняться сверху — вниз, когда первым тестируется главный модуль, затем вызываемые им модули и так далее до нижнего уровня.

При монолитном тестировании приходится почти для всех модулей разрабатывать как драйверы, так и заглушки, но благодаря этому можно каждый модуль всесторонне протестировать и можно распараллелить работу. Принципиальный недостаток: совсем не проверяются межмодульные интерфейсы, поэтому и сборка тестированных таким способом модулей называется «большой скачок», и найти места неправильно работающих интерфейсов часто весьма трудно.

При пошаговом тестировании при подключении нового модуля кроме его самого проверяется и его интерфейс. В ходе тестирования вновь подключенных модулей дополнительно протестируются и ранее подключенные. При этом тестирование не обязательно проводить уровень за уровнем, можно выделить часть модулей, которые обеспечивают решение значительной части, например, 75% задач, и начинать их внедрение, предупредив пользователя, что пока часть задач не решается. В ходе использования программный комплекс проходит дополнительную проверку по многим критериям.

## Тестирование программ и жизненный цикл программного продукта.
## Общая характеристика и назначение языка UML.
## Диаграммы вариантов использования, назначение, компоненты, отношения между компонентами.
## Диаграмма последовательности и кооперативная диаграмма, их назначение, компоненты.
## Диаграмма классов, характеристики класса
## Диаграмма классов, типы и характеристики отношений между классами.
## Диаграмма состояний:  назначение, компоненты.
## Диаграмма деятельности: назначение, компоненты.
## Диаграммы компонентов и размещения, их назначение, компоненты.
## Унифицированный процесс разработки программных средств. Общая характеристика и этапы. Основополагающие принципы разработки  программных средств по унифицированному процессу.
## Процесс определения требований к программным средствам. Документирование требований с помощью диаграмм. Функциональные и нефункциональные требования.

Функциональные - какие задачи должна решать программа.

Нефункциональные - какими характеристиками должна обладать программа.

## Особенности тестирования программных средств, построенных по объектно-ориентированной методике. Тестирование классов.
## Тестирование взаимодействия классов. Контрактное и защитное программирование. Тестирование иерархии классов.
## Сравнение  объектно-ориентированного и процедурного программирования.
## Лямбда-выражения на С++, их назначение, использование/ Организация обмена данными между лямбда-выражениями и основной программой на С++
## Объявление классов на C#.
## Особенности использования формальных и фактических параметров в функциях C# (out, ref). Составление процедурных программ.
## Наследование на C#, работа с конструкторами при наследовании.
## Индексаторы на C#.
## Свойства на C#.
## Делегаты на C#.
## Интерфейсы на C#.
## Виртуальные методы и абстрактные классы на C#.
## Исключительные ситуации на C# и их использование для повышения качества программ
## Класс  List на C#, создание и работа с классом List с нестандартными элементами. Применение языка LINQ.
## Классы SortedList и  Dictionary на C#, создание и работа с ними  с нестандартными элементами Применение языка LINQ.
38.	Лямбда-выражения и их использование на LINQ. Операторы Select, Where, Take, Skip, TakeWhile, SkipWhile
39.	Две разновидности синтаксиса  на LINQ
40.	Отложенное выполнение операторов на LINQ
41.	Агрегирующие функции на LINQ
42.	Группировка данных на LINQ
43.	Оператор соединения на LINQ
44.	Рефакторинг программ. Уровни рефакторинга.
45.	Методы рефакторинга внутри класса и в пределах иерархии классов.
46.	Отношение наследования на Java, работа с конструкторами при наследовании.
47.	Особенности работы с функциями на Java. Виртуальные функции на Java.
48.	Обобщение на Java, обобщение с ограничением.
49.	Интерфейсы на Java.
50.	Лямбда-выражения на Java, функциональные интерфейсы и их использование.
51.	Работа со стандартными классами на Java.
