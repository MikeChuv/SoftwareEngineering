**Программная инженéрия** определяется как системный подход к анализу, проектированию, оценке, реализации, тестированию, обслуживанию и модернизации программного
обеспечения. Программная инженерия занимается разработкой систематических моделей и надежных методов производства высококачественного программного обеспечения, и данный подход распространяется на все уровни - от теории и принципов до реальной практики создания программного обеспечения.

**Технология программирования** - изучение процессов программной инженерии, методов и инструментальных средств.


## Подходы к разработке программных средств. Их краткая характеристика.

Методы разработки программного обеспечения.

#### Метод функциональной декомпозиции.

Область применения: алгоритмически сложные задачи, не связанных с обработкой большого объема информации. (многие инж. задачи)

Задача делится на 2-8 подзадач (оптимально 3-5), каждая подзадача должна быть логически целой с чётко фиксированным набором исходных данных и результатом, любая задача более высокого уровня должна быть сведена к решению выделенных подзадач. Подзадачи также делятся на подзадачи, и т.д., пока не будут достигнуты критерии останова. Существует 2 критерия останова:
А) Выделена ПЗ, которая уже решена, или методы решения которой хорошо известны.
Б) Подзадача соответствует программно-разумным размерам. (ПРР – логику программы легко держать  в голове, т.е. не более 3-х экранов)

Иерархическая диаграмма:
![Метод Функциональной Декомпозиции](МетодФункциональнойДекомпозиции.png)

IPO - диаграмма (Input - Processing - Output: Ввод- Обработка - Вывод) должна соответствовать каждому узлу предыдущей диаграммы
![ВводОбработкаВывод](ВводОбработкаВывод.png)


####  Анализ потоков данных
Немного устарел, но может быть использован, например, при автоматизации малых офисов.

Диаграмма потоков данных (DFD, Data Flow Diagram):

![Диаграмма Потока Данных](ДиаграммаПотокаДанных.png)

#### Объектно-ориентированный подход

**Объект** - это реально существующий предмет со всеми его индивидуальными особенностями.

**Класс** - это множество объектов с одинаковыми свойствами и одинаковым поведением

#### Agile-методики
**Принципы:**
1. Нашим наивысшим приоритетом является удовлетворение клиента посредством ранней и непрерывной поставки ценного программного обеспечения.
2. Приветствуем изменение требований, даже на поздних стадиях разработки.
3. Agile-процессы позволяют использовать изменения для обеспечения заказчику конкурентного преимущества.
4. Работающий продукт следует выпускать как можно чаще, с периодичностью от пары дней до пары месяцев.
5. На протяжении всего проекта разработчики и представители бизнеса должны ежедневно работать вместе.
6. Над проектом должны работать мотивированные профессионалы. Чтобы работа была сделана, создайте условия, обеспечьте поддержку и полностью доверьтесь им.
7. Непосредственное общение является наиболее практичными эффективным способом обмена информацией как с самой командой, так и внутри команды.
8. Работающий продукт - основной показатель прогресса.
9. Инвесторы, разработчики и пользователи должны иметь возможность поддержать постоянный ритм бесконечно. Agile помогает наладить такой устойчивый процесс разработки.
10. Постоянное внимание к техническому совершенству и качеству проектирования повышает гибкость проекта.
11. Простота - искусство минимизации лишней работы - крайне необходима.
12. Самые лучшие требования, архитектурные и технические решения рождаются у самоорганизующихся команд.
13. Команда должна систематически анализировать возможные способы улучшения эффективности и соответственно корректировать стиль своей работы.

**SCRAM-технология и экстремальное (ХР) программирование**
- Постоянное сотрудничество заказчика и разработчика, от постановки задачи до тестирования.
- Разработка маленькими шагами, результаты которых тут же тестируются и будут предъявлены заказчику.
- Пожелания заказчика по усовершенствованию по возможности тут же будут реализованы.
- Разработку ведет относительно малочисленная группа специалистов, которые друг другу полностью доверяют, могут договориться. Отсутствует руководитель проекта, который распределяет задания и проверяет их выполнение.

**Критерии применения гибких методик**

Важны два параметра: критичность и масштаб.

_Критичность_ определяется последствиями потери работоспособности программного
обеспечения. Выделены 4 уровня:
- `С` - потеря удобства.
- `D` - потеря восстанавливаемых ресурсов (материальных, финансовых).
- `Е` - потеря невосстанавливаемых ресурсов (материальных, финансовых).
- `L` - угроза техногенных катастроф.

Масштаб определяется количеством занятых в разработке специалистов:
- 1 - 6: малый,
- 7 - 20: средний,
- Более 20: большой.
-
Гибкие методики могут применяться при критичности С и В и при малых и средних разработках.

## Жизненный цикл программного продукта. Основные понятия.

**Жизненный цикл** - это развитие системы, продукта, услуги, проекта или других изготовленных человеком объектов, начиная со стадии разработки концепции и заканчивая прекращением применения.
Другими словами можно сказать, что жизненный цикл программного обеспечения охватывает промежуток времени от возникновения необходимости в нем до завершения его эксплуатации.
При возникновении такой необходимости возникает и вечный вопрос: приобрести уже готовый продукт или разработать собственный.

#### Процессы жизненного цикла
1. Процесс анализа требований (функциональных и нефункциональных) к программным средствам
2. Процесс проектирования архитектуры программных средств - разработка общих принципов построения.
3. Процесс детального проектирования программных средств - из каких компонентов будет состоять, какие будут базы данных
4. Процесс конструирования программных средств - написание текстов программ и локальная отладка
5. Процесс комплексирования программных средств - сборка всех компоненов и проверка их работоспособности.
6. Процесс квалификационного тестирования программных средств - заключительное тестирование проводит не автор программы
  - _альфа_ - внутри компании разработчика, но без участия разработчиков
  - _бета_ - использование потенциальными пользоваетелями некоммерческой версии программы
7. Поставка и внедрение (использование программы без присутствия разработчика)
  - Опытная эксплуатация - работают разработчик и пользоваетль.
  - Промышленная эксплуатация - программа работает в реальных условиях без постоянного пристутствия разработчика.
8. Сопровожение программного продукта
  - устранение выявленных ошибок, внесение изменений, вызванных внешними факторами,
  - накопление предложений для разработки следующей версии,
  - внесение непринципиальных усовершенствований,
  - организованный переход к следующей версии с минимальными затратами

**Укрупненная модель жизненного цикла** (разработка небольших программных средств)
- анализ требований (превращение прикладной задачи в программистскую)
- проектирование структуры;
- программирование, тестирование, отладка;
- сборка, валидация, верификация (+ на этом этапе надо убедиться, что программа удовлетворяет требованиям, определенным на первом этапе)
- внедрение;
- сопровождение.

**Валидация** (validation): подтверждение того, что требования, предназначенные для конкретного использования или применения, выполнены. Валидация представляет собой совокупность действий, гарантирующих и обеспечивающих уверенность в том, что система способна реализовать свое предназначение, текущие и перспективные цели.

**Верификация** (verification): подтверждение того, что заданные требования полностью выполнены. Верификация представляет собой совокупность действий по сравнению полученного результата жизненного цикла с требуемыми характеристиками для этого результата.

## Модели жизненных циклов программного обеспечения, их характеристики и области применения.

В ходе реализации разработчик должен определить модель жизненного цикла, соответствующую области применения, размерам и сложности проекта. Модель жизненного цикла должна содержать стадии, цели и выходы каждой стадии. Виды деятельности и задачи процесса реализации программных средств должны быть выбраны и отражены в модели жизненного цикла. Эти виды деятельности и задачи могут пересекаться или взаимодействовать друг с другом, могут выполняться итеративно или рекурсивно.

Модель жизненного цикла показывает как между собой связаны этапы разработки программного обеспечения.

**Каскадная модель - водопад**

Особенности: полностью отсутствуют обратные связи (каждый этап считается полностью законченным до перехода к следующему), что упрощает процесс разработки, но является слишком жёстким требованием для реализации сложных проектов; ошибка, допущенная на этапе анализа, пересекает весь проект, и исправлять её сложно.

По этой модели можно работать в 2 случаях: разработка очередной версии существующего ПО; реализация простого проекта опытным разработчиком.

Устранение ошибок, допущенных на ранних этапах обойдется намного дороже исправления ошибок, допущенных на более поздних

Источник - статья У.Ройса 1970 года, из которой эта модель была выделена по ошибке.

![Каскадная Модель](КаскаднаяМодель.png)


## Особенности модели жизненного цикла «спираль»

Особенности: Раскручивается версия за версией, постепенно расширяется функционал. В идеале расширение аддитивное (внесение нового, без изменения старого).

Проблема: Успех разработки в большой степени определяется тем, в какой последовательности выбрана реализация. Основной принцип - как в строительстве: сначала фундамент (то есть общие части) и т.д. То есть при получении задачи нужно узнать, какие нужно накапливать данные, чтобы развивать данную задачу.

Применяется регрессионное тестирование, то есть в начале нужно провести тесты, предназначенные для предыдущей версии.

Предпроектное исследование - анализ рисков - принятие решения - разработка первой версии (м.б. прототипом) - анализ рисков (результатов)...

![Спираль](Спираль.png)

## Методы «быстрой разработки» их суть и условия применения.

Быстрая разработка приложений (RAD, rapid application development) - это жизненный цикл процесса проектирования, созданный для достижения более высокой скорости разработки и качества ПО и более низкой стоимости разработки, чем это возможно при традиционном подходе к проектированию.

Технологию RAD целесообразно применять, если:
-  Необходимо выполнение проекта в сжатые сроки.
-  Нечетко определены требования к ПО.
-  Проект выполняется в условиях ограниченности бюджета.
-  Интерфейс пользователя главный фактор.
-  Возможно разбиение проекта на функциональные компоненты.
-  Низкая вычислительная сложность ПО.

Основные принципы RAD:
- Работа ведется группами (руководитель, аналитик, два программиста, технический писатель) Если проект сложный, то для него может быть выделено несколько RAD-групп. Разработка проекта выполняется в условиях тесного взаимодействия между разработчиками и Заказчиком.
- Разработка базируется на моделях. Моделирование позволяет оценить проект и выполнить его декомпозицию на составные части, каждая из которых может разрабатываться отдельной RAD-группой.
- Итерационное прототипирование. Разработка системы и предъявление ее заказчику осуществляется в виде последовательности развиваемых прототипов. Любой из прототипов реализует определенную часть функциональности, требуемой от конечного продукта. При этом каждый последующий прототип включает всю функциональность, реализованную в предыдущем прототипе, с добавлением новой. Традиционно для проектов ПО средней сложности разрабатываются три прототипа. Первый содержит весь пользовательский интерфейс с нулевой функциональностью. Второй прототип содержит реализованную на 70-80% функциональность системы, третий – полностью реализованную функциональность.
- RAD группа всегда работает только над одним прототипом.
- Если проект сложный, то для него может быть выделено несколько RAD групп.
- Обязательное использование инструментальных средств, автоматизирующих процесс разработки, и методик их использования, следствием чего является сокращение сроков разработки и повышение качества конечного продукта.


## Планирование разработки программного обеспечения. LOC и FP-метрики. СОСОМО модель.

**План разработки программного обеспечения** (план проекта). План определяет _порядок работ, ресурсы, обязанности,_ и так далее. Может быть как маленьким и относительно неформальным так и большим и полностью официальным. Создание плана проекта столь же важно, как и само проектирование кода.

Процесс руководства программным проектом начинается с множества действий, объединяемых общим названием **планирование проекта**. Первое из этих действий - **_выполнение оценки_**. Очень важно провести оценку с минимальным риском.

Цель выполнения оценки проекта на основе LOC- и FP-метрик - сформировать предварительные оценки, которые позволят:
- предъявить заказчику корректные требования по стоимости и затратам на разработку программного продукта;
- составить план программного проекта.
При выполнении оценки возможны два варианта использования LOC- и FP-данных:
- в качестве оценочных переменных, определяющих размер каждого элемента продукта;
- в качестве метрик, собранных за прошлые проекты и входящих в метрический базис фирмы.


#### LOC и FP-метрики.

**Размерно-ориентированные метрики** прямо измеряют программный продукт и процесс его разработки. Основываются размерно-ориентированные метрики на LOC-оценках (Lines Of Code). LOC-оценка — это количество строк в программном продукте.

Достоинства размерно-ориентированных метрик (основываются на LOC - lines of code):
- широко распространены;
- просты и легко вычисляются.

Недостатки размерно-ориентированных метрик:
- зависимы от языка программирования;
- требуют исходных данных, которые трудно получить на начальной стадии проекта;
- не приспособлены к непроцедурным языкам программирования.

**Функционально-ориентированные метрики** косвенно измеряют программный продукт и процесс его разработки. Вместо подсчета LOC-оценки при этом рассматривается не размер, а функциональность или полезность продукта. Используется 5 информационных характеристик для подсчета FP (Function Points):
- Количество внешних вводов
- Количество внешних выводов
- Количество внешних запросов
- Количество внутренних логических файлов
- Количество внешних интерфейсных файлов

После сбора всей необходимой информации приступают к расчету метрики — количества
функциональных указателей.

Достоинства функционально-ориентированных метрик: не зависят от ЯП, легко вычисляются на любой стадии проекта.

Недостаток функционально-ориентированных метрик: результаты основаны на субъективных данных, используются не прямые, а косвенные измерения.

**COCOMO** - Constructive Cost Model (модель издержек разработки). Оценка стоимости программного продукта.


## Виды контроля программ; статические и динамические методы контроля. Тестирование  и отладка.

#### Виды контроля программ
- визуальный контроль - чтение программы (проверка условий в условных операторах и цаклах, возможность не завершения итерационных циклов и т.д.)
- Статический контроль – проверка программы по ее тексту без выполнения с помощью инструментальных средств. Синтаксический контроль выполняется компилятором.
- Динамический контроль – проверка правильности программы и ее выполнение на компьютере.

[Еще](https://life-prog.ru/view_ppdkss.php?id=18)

#### Тестирование  и отладка.
Тестирование — это запуск программы на разных наборах исходных данных — тестах и анализ полученных результатов с целью обнаружения ошибок.

Заключительное тестирование проводит не автор программы.

Виды тестирования:
- _альфа-тестирование_ - внутри компании разработчика, но без участия разработчиков
- _бета-тестирование_ - использование потенциальными пользоваетелями некоммерческой версии программы

Отладка - выявление причин некорректного поведения программы и их устранение.

## Методы функционального тестирования.

Функциональное тестирование является одним из ключевых видов тестирования, задача которого — установить соответствие разработанного программного обеспечения исходным функциональным требованиям заказчика. Проведение функционального тестирования — процесс, позволяющий проверить способность информационной системы работать в определенных условиях и решать задачи, нужные пользователям.

#### Метод эквивалентного разбиения.

Множество значений исходных данных разделяют на непересекающиеся подмножества таким образом, чтобы внутри каждого подмножества все значения были равносильны в качестве теста, но значения из разных подмножеств — нет.

Правильный класс эквивалентности — это допустимые значения исходных данных, неправильный класс эквивалентности — недопустимые значения. Например, для функции `у = ln(x)` допустимым классом эквивалентности является `x>0`, недопустимым `x<=0`.

#### Метод граничных значений.

Этот метод требует использовать в качестве тестов значения на границах и около границ классов эквивалентности.

Для уменьшения количества тестов рекомендуют использовать эти два метода совместно: сначала составить тесты по эквивалентному разбиению, а затем подкорректировать их таким образом, чтобы соблюдались рекомендации второго метода.

## Методы структурного тестирования. Граф управления программы. Тестирование путей, цикломатическая сложность программы.

В любой программе присутствуют три базовых конструкции: последовательность, выбор и повторение (цикл). Последовательности в графе управления можно ставить в соответствие одну вершину или столько вершин, сколько действий имеется в последовательности. Любой повтор (цикл) может быть реализован через выбор. Оператору цикла ставится в соответствие столько вершин графа, сколько условий продолжения (прерывания) цикла.

Для тестирования «белого ящика» необходимо пропускать столько тестов, сколько путей имеется на графе управления.

Интерпретация: цикломатическая сложность — это количество путей от первой вершины до последней.

Цикломатическая сложность программы определяется по формуле `Количество_ребер - количество_вершин + 2`. Цикломатическая сложность последовательности всегда равна единице. Поэтому можно при составлении графа управления программой последовательность представить одной вершиной.

Пример графа управления для следующего фрагмента:
```cpp
x = 3.4;
z = x * y;
if (z > 7.2) n++;
else m++;
y = z * n;
```
![Граф Управления](ГрафУправления.png)

## Совместное использование функционального и структурного тестирования.

Тестирование «серого ящика»:
1. На основе спецификации программы составим тесты методами «черного ящика». Допустим, получили N тестов.
2. Пусть на графе управления существует M путей.

Возможны следующие случаи:
1. `N = M` и составленные тесты обеспечивают прохождение всех путей по меньшей мере по одному разу. Все хорошо!
2. `N = M`, но обеспечивается прохождение лишь K путей (K < M). Если оставшиеся М-К путей противоречивые, то два или более теста будут пройдены по одному и тому же пути. Если это так и должно быть, то можно, в принципе, уменьшить количество тестов, но вполне возможно, что этого не стоит делать! Если так не должно быть (два теста пройдут по одному пути, но на самом деле они разные) — значит в программе ошибка!
3. `N = M`, но обеспечивается прохождение лишь K путей (K < M), среди оставшихся М-К путей имеются реальные, то не все протестировано и количество тестов надо увеличить.
4. `N < M`. Если оставшиеся М-N путей противоречивые, то все хорошо, можем приступить к тестированию, но если это не так, то придется составить и для них тесты.
5. `M < N`, значит, два или более теста пройдут по одному и тому же пути. Если так и должно быть, то некоторые случаи будут протестированы повторно. Если нет, то два разных случая пройдут по одному и тому же пути и в программе ошибка.

## Тестирование программных комплексов, построенных методом функциональной декомпозиции

[Тут про сам метод](#метод-функциональной-декомпозиции)

1. **_Монолитное_** тестирование. Все составные части тестируются независимо друг от друга, и после завершения этого выполняется сборка всего комплекса. Такую сборку иногда называют» «большой скачок».
2. **_Пошаговое_** (или **_инкрементное_**) тестирование, где протестированные модули тут же подключают к комплексу, тестирование и сборка выполняются параллельно. Пошаговое тестирование может выполняться сверху — вниз, когда первым тестируется главный модуль, затем вызываемые им модули и так далее до нижнего уровня.

При монолитном тестировании приходится почти для всех модулей разрабатывать как драйверы, так и заглушки, но благодаря этому можно каждый модуль всесторонне протестировать и можно распараллелить работу. Принципиальный недостаток: совсем не проверяются межмодульные интерфейсы, поэтому и сборка тестированных таким способом модулей называется «большой скачок», и найти места неправильно работающих интерфейсов часто весьма трудно.

При пошаговом тестировании при подключении нового модуля кроме его самого проверяется и его интерфейс. В ходе тестирования вновь подключенных модулей дополнительно протестируются и ранее подключенные. При этом тестирование не обязательно проводить уровень за уровнем, можно выделить часть модулей, которые обеспечивают решение значительной части, например, 75% задач, и начинать их внедрение, предупредив пользователя, что пока часть задач не решается. В ходе использования программный комплекс проходит дополнительную проверку по многим критериям.

## Тестирование программ и жизненный цикл программного продукта.

МБ тут надо про методы проверки?? (6.1 пособия от Марана стр 160)

Тестирование примитивных программ (?)
Примитивными считаем программы, не содержащие вызовов функций. Рекомендуется, чтобы объем такой программы не превышал 1–2 экрана. Существуют два подхода их тестирования:
- Тестирование «черного ящика», равнозначные термины: функциональное тестирование, тестирование по данным.
- Тестирование «белого ящика», равнозначные термины: тестирование по управлению, структурное тестирование. Некоторые авторы говорят еще о тестировании «серого ящика», подразумевая под этим совместное применение обоих подходов.
- Метод функциональных диаграмм (метод причинно-следственных связей)
- Предположение об ошибке (на основе опыта тестировщик предполагает где какие ошибки могут быть и нацеливает туда проверки)

[Тут про жизненный цикл](#жизненный-цикл-программного-продукта-основные-понятия)

## Общая характеристика и назначение языка UML.

UML - Unified Modelling Language (универсальный язык моделирования) - это язык графического моделирования, широко применяемый при разработке программных средств по объектно-ориентированной методике. Предназначен для выполнения этапов анализа и проектирования программных средств.

С помощью языка UML можно выполнять следующие задачи:
- описание требований к разрабатываемой системе;
- описание структуры и бизнес-процессов предметной области;
- проектирование архитектуры программного продукта;
- проектирование размещения программного продукта в сети;
- генерация структуры объектно-ориентированной программы.

UML — это язык диаграмм.
Классификация диаграмм:
1. Структурные диаграммы:
  - диаграмма классов (Class Diagram);
  - диаграмма компонентов (Component Diagram);
  - диаграмма размещения (Deployment Diagram).
2. Диаграммы поведения:
  - диаграмма вариантов использования (Use Case Diagram);
  - диаграмма деятельности (Activity Diagram);
  - диаграмма состояний (State Machine Diagram);
  - диаграммы взаимодействия (Interaction Diagram):
    - диаграмма коммуникации (Communication Diagram);
    - диаграмма последовательностей (Sequence Diagram).

## Диаграммы вариантов использования, назначение, компоненты, отношения между компонентами.

**Назначение**

Предназначена для документирования требований к разрабатываемому программному продукту. Она показывает, кто является потенциальными пользователями и для решения каких задач они могут в будущем обращаться к создаваемому программному продукту.

Главное назначение диаграммы вариантов использования заключается в формализации функциональных требований к системе с помощью действующих лиц — потенциальных пользователей и вариантов использования — задач, с которыми они будут обращаться к разрабатываемому программному продукту.

**Компоненты**

Основными компонентами диаграммы вариантов использования являются действующие лица (в литературе используют равнозначные термины − актер, актант), варианты использования (равнозначный термин — прецедент) и отношения между ними.

**Отношения**

На диаграмме вариантов использования могут быть применены (и показаны на ней) следующие виды отношений:
- отношение ассоциации (association relationship)
- отношение расширения (extend relationship);
- отношение включения (include relationship);
- отношение обобщения (generalization relationship).

Отношение **ассоциации** используется для задания взаимодействия действующего лица и вариантов использования: какое действующее лицо какие варианты использует.
- Отсутствие стрелки - действующее лицо запускает вариант использования, и результат передается ему же.
- Стрелка, направленная от действующего лица - лицо запускает вариант, но результат ему не передается (за исключением сообщения типа «Выполнено»)
- Стрелка от варианта использования - действующее лицо не может запускать вариант, ему лишь сообщают результат, если этот вариант был кем-то запущен.

Отношение **расширения** используется между вариантами использования: оно указывает, что один вариант расширяет возможности другого, но это расширение не имеет обязательного характера, а предоставляет дополнительные возможности, которые потребуются не всегда (например, подзадача, которая
может возникнуть или нет).

Отношение **включения** показывает, что один вариант использования всегда включает и другой вариант использования (например, как подзадачу, которую придется всегда решить).

Отношение **обобщения** связывает менее общее с более общим.

![Диаграмма Вариантов Использования](ДиаграммаВариантовИспользования.png)

## Диаграмма последовательности и кооперативная диаграмма, их назначение, компоненты.

#### Диаграмма последовательности
Каждому варианту использования должна соответствовать диаграмма последовательностей, которая отражает последовательность обмена сообщениями именно для этого варианта. Исполнение многих вариантов использования может протекать по-разному в зависимости от обстоятельств, например резервирование товара в случае наличия или отсутствия требуемого количества. Диаграмма последовательности служит, в первую очередь, для визуализации временных аспектов взаимодействия.

**Сообщение** (message) представляет собой законченный фрагмент информации, который отправляется одним объектом другому (обращение из одного объекта к методу в составе другого объекта).

При подаче **синхронного** сообщения процесс может продолжаться лишь после получения ответа от адресата. При **асинхронном** сообщении процесс продолжается сразу послеего отправки.

У верхнего края диаграммы на горизонтальной линии находятся **_объекты_**, которые существуют с самого начала работы программы. **_Линия жизни_** объекта изображается _пунктирной вертикальной линией_. Эта линия служит для обозначения периода времени, в течение которого объект существует и может участвовать в обмене сообщениями. Очевидно, что для создания объекта должен быть запущен конструктор его класса, а также даны значения некоторому подмножеству его данных. Следует также иметь в виду, что один объект может передать сообщение другому лишь тогда, когда среди его данных имеется адрес того. Для явного выделения состояния объекта применяется **_фокус управления_**, который изображается в форме _вытянутого узкого прямоугольника_, верхняя сторона которого обозначает начало активности, а нижняя сторона − ее конец.

Сообщения показаны на диаграмме горизонтальными линиями. Имеются следующие стереотипы сообщений:
- Call (вызвать) — сообщение, требующее вызова метода класса- адресата. Это сообщение может быть рефлексивным, тогда оно требует вызова метода в классе-отправителе;
- Return (возвратить) — возвращает результат выполнения сообщения Вызвать;
- Create (создать) — сообщение, требующее создание другого объекта;
- Destroy (уничтожить) — сообщение с требованием уничтожения объекта-адресата.

![Диаграмма Последовательности](ДиаграммаПоследовательности.png)

#### Диаграмма кооперации
Диаграмма кооперации служит для представления структурных аспектов.

Наличие _сплошной линии_ между объектами показывает, что между ними могут передаваться сообщения. Сами сообщения показаны рядом с линиями. _Цифры у сообщений_ показывают очередность их возникновения. Рядом с сообщениями может быть указан метод класса адресата. На основе диаграммы последовательности кооперативная диаграмма может быть создана автоматически.

![Диаграмма Кооперации](ДиаграммаКооперации.png)

## Диаграмма классов, характеристики класса

Диаграмма классов служит для представления **_статической структуры модели системы_** в терминологии объектно-ориентированного программирования. Диаграмма классов отражает структуру отдельных классов и их взаимосвязи и состоит из классов и отношений между ними.

**Название класса** должно быть уникальным в пределах модели, они образуют в будущем словарь предметной области

**Атрибуты** (или свойства) класса задают набор его характеристик.

**Операции** класса задают услуги, которые могут быть запрошены у любого объекта данного класса. Операциями заданы задачи, которые могут быть решены на объектах данного класса.

Стереотипы
- Действующее лицо (Actor)
- граничный класс (Boundary) используется для задания взаимодействия разрабатываемого программного продукта с внешней средой. Поэтому каждому действующему лицу должен соответствовать граничный класс.
- Сущность (Entity) используется для классов, предназначенных для создания баз данных
  - Сущность Управление (Control) предназначена для управления работой программного продукта.

Все стереотипы классов имеют одинаковую структуру, рассмотренную нами выше: название, атрибуты, операции.

![Стереотипы Классов](СтереотипыКлассов.png)

## Диаграмма классов, типы и характеристики отношений между классами.

Между классами имеются следующие отношения:
- обобщения (generalization);
- ассоциации (association);
- зависимости (dependency);
- реализации (realization).

**Отношение обобщения** связывает класс, соответствующий более общему понятию (предок), с менее общими понятиями − классами (потомками). Равносильные термины родительский класс — дочерний класс.

**Отношение ассоциации** показывает наличие содержательной связи между двумя классами. Разновидности: **агрегации** (один класс содержит в какой-то ситуации в своем составе другие классы, но они могут существовать и независимо друг от друга.) и **композиции** (отношение «целое — часть», то есть составные части не имеют смысла без своего владельца)

**Отношение зависимости** определяет, что изменение одного класса может повлиять на другой класс, который его использует, причем обратное в общем случае неверно.

**Отношение реализации** задается между классами, один из которых описывает действия, а другой гарантирует их выполнение. Чаще всего реализации используют для определения отношений между интерфейсом и классом, который предоставляет объявленные в интерфейсе операции или услуги. Интерфейс позволяет отделить спецификацию (сам интерфейс) от реализации.

![Диаграмма Классов](ДиаграммаКлассов.png)

## Диаграмма состояний: назначение, компоненты.

**Назначение**

Будем говорить о состояниях классов, подразумевая при этом, что все объекты этого класса будут находиться в одинаковых состояниях. Переход объектов класса из одного состояния в другое задает характерные черты их поведения.

Она позволяет лучше понимать функционирование исследуемой системы. Если какой-либо класс имеет ярко выраженное динамическое поведение, то разработка этой диаграммы желательна.

**Компоненты**
![Компоненты Диаграммы Состояний](КомпонентыДиаграммыСостояний.png)


## Диаграмма деятельности: назначение, компоненты.

**Назначение**

Диаграммы деятельности предназначены для моделирования поведения, иногда их называют «ОО блок-схемы». Например, с их помощью можно описать работу варианта использования. Действие — это элементарная работа, не подлежащая дальнейшей детализации.

**Компоненты:**
- действие
- проверка условия
- конец разветвления (обязательно, если есть начало)
- линия синхронизации (следующие за ней
действия могут выполняться одновременно, но все они должны быть выполнены)
- сигнал (завершение действия передается за пределы системы)
- прием сигнала (ожидание сигнала со стороны)
- узел соединения (можно двигаться дальше лишь при условии, что все параллельно выполняемые ветви завершились, не обязательно одновременно)

![Диаграмма Деятельности](ДиаграммаДеятельности.png)

## Диаграммы компонентов и размещения, их назначение, компоненты.

#### Диаграммы компонентов
Диаграмма компонентов описывает особенности физического представления создаваемой системы. Компонент — это модульная и замещаемая часть системы, который взаимодействует с другими компонентами через строго определенный интерфейс. Замена одного компонента на другой с таким же интерфейсом и функционалом не должна влиять на работу системы в целом.

Все классы должны содержаться в компонентах. Другими словами, компоненты состоят из классов.

#### Диаграммы размещения
Диаграмма развертывания (размещения) показывает какие компоненты на каких компьютерах работают и как эти компьютеры связаны.

Компоненты (?)

## Унифицированный процесс разработки программных средств. Общая характеристика и этапы. Основополагающие принципы разработки  программных средств по унифицированному процессу.

Фундаментальные принципы унифицированного процесса (в дальнейшем УП) заключаются в следующих утверждениях:
- УП управляется вариантами использования;
- УП является архитектурно-ориентированным;
- УП является итеративным и инкрементным.

**_Пользователь_** — это нечто внешнее относительно создаваемого программного продукта. Пользователь обращается к программному продукту со своими задачами и ждет от него определенной последовательности действий. Такое взаимодействие является вариантом использования. **_Вариант использования_** — это часть функциональности системы, необходимая для получения пользователем значимого результата.

Понятие архитектура программного продукта включает в себя наиболее важные статические и динамические его аспекты. **_Архитектура_** — это представление всего проекта с выделением важных характеристик и затушевыванием деталей. Варианты использования определяют функции, а архитектура - форму. На основе анализа ключевых вариантов использования разрабатывается архитектура создаваемого программного продукта, которая в ходе дальнейшей работы над проектом должна расширяться и дополняться, но не переделываться кардинальным образом.

Разработка разделяется на относительно небольшие части, так называемые _мини-проекты_. Каждый мини-проект является **_итерацией_**, результатом которой будет приращение (**_инкремент_**). Итерации относятся к процессу разработки, а приращения — к выполняемому проекту.


Фазы:
- фаза анализа (идея превращается в концепцию готового продукта и создается план его разработки)
- фаза проектирования (детально описывается большинство вариантов использования и разрабатывается архитектура системы)
- фаза реализации (создание продукта)
- фаза внедрения (бета-версия продукта)



## Процесс определения требований к программным средствам. Документирование требований с помощью диаграмм. Функциональные и нефункциональные требования.

Цель определения требований − ответить на вопрос, что должно делать создаваемое программное обеспечение для каждого потенциального пользователя?

Типовой рабочий процесс определения требований включает следующие тесно взаимосвязанные шаги:
- перечисление возможных требований;
- описание контекста системы;
- определение функциональных требований;
- определение нефункциональных требований.

(?) Что про диаграммы? Составление диаграммы вариантов использования?

Функциональные - какие задачи должна решать программа. Их определение заключается в разработке модели вариантов использования.

Нефункциональные - какими характеристиками должна обладать программа.

В результате выполнения работ по определению требований должны быть получены (программа-минимум):
1. Описание контекста системы.
2. Модель вариантов использования (одна или несколько диаграмм).
3. Эскизы интерфейсов пользователей для всех действующих лиц.
4. Описания вариантов использования.
5. Основные нефункциональные требования.

## Особенности тестирования программных средств, построенных по объектно-ориентированной методике. Тестирование классов.

Основной моделью жизненного цикла программного обеспечения, разрабатываемого по объектно-ориентированной методике, является спираль. Поэтому важно проверить при добавлении новых возможностей, выполняются ли корректно те задачи, которые уже были реализованы в предыдущих версиях. Это называется регрессионным тестированием. **_Регрессионное тестирование_** заключается в том, что перед проверкой работы новых возможностей мы запустим тесты, на которых проверили предыдущую версию.

[Про спираль](#особенности-модели-жизненного-цикла-спираль)

Различают:
- Тестирование примитивных классов
- Тестирование взаимодействия классов
- Тестирование иерархии классов

#### Тестирование примитивных классов
Класс называется примитивным, если он только принимает сообщения и не создает динамически экземпляры других классов. Так как в классе могут содержаться приватные поля, при тестировании их можно сделать публичными, а после - вернуть окончательные атрибуты доступа.

## Тестирование взаимодействия классов. Контрактное и защитное программирование. Тестирование иерархии классов.

#### Контрактное и защитное программирование.

При **контрактном** подходе выполнение предусловий (условие, которое должно быть выполнено перед операцией, в противном случае операция не может быть выполнена) обеспечивают вместе отправитель и получатель. Отправитель должен обеспечить принадлежность исходных данных допустимым классам эквивалентности. Но в общем случае это является достаточным, но не необходимым условием успешного выполнения функции. Например, требуется 2 билета на определенный рейс. Все данные корректные, но билетов может не быть. Если корректность исходных данных достаточное условие для выполнения функции — то этот вопрос не стоит.

_Вывод для тестирования:_ при контрактном подходе тестирование на неправильных классах эквивалентности не требуется.

При **защитном** программировании гарантии корректности исходных данных нет, и функция сама должна обеспечить, чтобы «мусор на входе не превратили мусором на выходе». Допустимы оба подхода, но тесты должны разрабатываться с учетом применимого подхода.

#### Тестирование взаимодействия классов.
Сообщения, получаемые пассивным классом, можно разделить на две категории:
- сообщения, полностью обрабатываемые этим классом (применяют регрессионное тестирование и тестирование примитивного класса)
- сообщения, которые вызывают отправку сообщения другому классу (применяют тестирование, похожее на тестирование модулей промежуточных уровней при функциональной декомпозиции)

При применении контрактного программирования должно быть установлено, что никакая функция при допустимых классах эквивалентности на входе не порождает недопустимых классов на выходе.

Хорошим помощником при составлении тестов для тестирования взаимодействия классов являются _диаграммы последовательностей_, которые показывают реализацию вариантов использования со всеми возможными альтернативными путями. Все возможные пути их реализации должны быть протестированы.


#### Тестирование иерархии классов.
Выполняется от класса-предка к наследникам. Класс-наследник содержит все данные класса-предка (кроме закрытых) и может пользоваться функциями-членами класса-предка (кроме закрытых). При отправлении сообщения классу-наследнику существуют два варианта: оно будет обработано функцией-членом класса или наследованной функцией. Если наследованная функция уже протестирована при тестировании класса-предка, то таким образом можно уменьшить объем тестирования. Но при этом надо обратить внимание на виртуальные функции: имеют ли они новую реализацию в классе-наследнике или нет. Принцип простой: следует тщательно следить за тем, чтобы ВСЕ реализации виртуальных функции были полностью протестированы.

Другая проблема заключается в тестировании абстрактных классов.  Можно использовать два подхода:
1. Заменить на время тестирования такого класса абстрактную функцию заглушкой.
2. Закомментировать абстрактную функцию на время тестирования и проводить тестирование ее реализации только при тестировании классовнаследников.


## Сравнение объектно-ориентированного и процедурного программирования.

#### Процедурное программирование

Процедурное программирование — программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы, то есть более крупные целостные единицы кода, с помощью механизмов самого языка. Основная идея процедурного программирования - использование памяти для хранения данных. Основная команда- присвоение, с помощью которой определяется и меняется память компьютера. Программа производит преобразование содержимого памяти, изменяя его от исходного состояния к результирующему.

В процедурной программе модули взаимодействуют посредством состояния чтения и записи, которое хранится в общих структурах данных.

#### Объектно-ориентированное программирование

В объектно-ориентированной программе модули в виде объектов взаимодействуют путем отправки сообщений другим объектам.

Базовые принципы:
- Объект - базовая единица объектно-ориентированной системы.
- Посылка сообщений - единственный способ обмена информацией между объектами.
- Каждый объект относится к какому-то классу.
- Поведение объекта определяется его классом.
- Классы наследуют функциональность от предка.

Парадигмы ООП:
- инкапсуляция (объединение данных и функций, которые управляют этими данными, в единый компонент)
- наследование (механизм языка, позволяющий описывать новый класс на основе существующего)
- полиморфизм (свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта)
- *абстракция (предствление объекта минимальным набором полей и методов)
- *посылка сообщений (вызов объектом метода другого объекта)



## Лямбда-выражения на С++, их назначение, использование/ Организация обмена данными между лямбда-выражениями и основной программой на С++
## Объявление классов на C#.
## Особенности использования формальных и фактических параметров в функциях C# (out, ref). Составление процедурных программ.
## Наследование на C#, работа с конструкторами при наследовании.
## Индексаторы на C#.
## Свойства на C#.
## Делегаты на C#.
## Интерфейсы на C#.
## Виртуальные методы и абстрактные классы на C#.
## Исключительные ситуации на C# и их использование для повышения качества программ
## Класс  List на C#, создание и работа с классом List с нестандартными элементами. Применение языка LINQ.
## Классы SortedList и  Dictionary на C#, создание и работа с ними  с нестандартными элементами Применение языка LINQ.
38.	Лямбда-выражения и их использование на LINQ. Операторы Select, Where, Take, Skip, TakeWhile, SkipWhile
39.	Две разновидности синтаксиса  на LINQ
40.	Отложенное выполнение операторов на LINQ
41.	Агрегирующие функции на LINQ
42.	Группировка данных на LINQ
43.	Оператор соединения на LINQ
44.	Рефакторинг программ. Уровни рефакторинга.
45.	Методы рефакторинга внутри класса и в пределах иерархии классов.
46.	Отношение наследования на Java, работа с конструкторами при наследовании.
47.	Особенности работы с функциями на Java. Виртуальные функции на Java.
48.	Обобщение на Java, обобщение с ограничением.
49.	Интерфейсы на Java.
50.	Лямбда-выражения на Java, функциональные интерфейсы и их использование.
51.	Работа со стандартными классами на Java.
